	Обзор библиотек	
1. Logging
Библиотека logging — это мощный, гибкий и стандартный модуль Python для записи сообщений о событиях, происходящих во время работы программы. Она позволяет отслеживать ошибки, анализировать поведение программы, отлаживать код и собирать статистику. 
Почему мы  используем  logging? 
1. Отладка: Вместо того, чтобы выводить отладочную информацию с помощью print(), logging позволяет делать это контролируемо, с разными уровнями детализации, и направлять вывод в разные места (консоль, файл, сеть). 
2. Мониторинг: Можно отслеживать, как программа ведет себя в "боевых" условиях, какие ошибки возникают, насколько часто. 
3. Аудит: Запись действий пользователей или системных событий для последующего анализа. 
4. Гибкость: Возможность настроить, какие сообщения записываются, куда записываются, и в каком формате. 
Основные компоненты logging logging работает с несколькими ключевыми компонентами: 
1. Logger (Логгер): 

• Основной объект, через который происходит запись сообщений. 
• У каждого логгера есть имя (обычно соответствующее имени модуля, например, logging.getLogger(__name__)). 
• Имена логгеров образуют иерархию (как файловая система), что позволяет управлять настройками наследуемо. 
2. Handler (Обработчик): 
• Определяет, куда будут направлены сообщения логгера. 
• Примеры: 
* StreamHandler: Выводит сообщения в поток (например, sys.stdout или sys.stderr — консоль). 
        * FileHandler: Записывает сообщения в файл. 
* RotatingFileHandler: Записывает сообщения в файл, автоматически создавая новые файлы при достижении определенного размера или количества. 
*TimedRotatingFileHandler: Как RotatingFileHandler, но переключение файлов происходит по времени (например, ежедневно). 
        * HTTPHandler: Отправляет сообщения по HTTP. 
        * SocketHandler: Отправляет сообщения по сети. 
3. Formatter (Форматтер): 
• Определяет, как будут выглядеть сообщения логов. 
• Позволяет включить в сообщение: время, уровень сообщения, имя логгера, имя модуля/функции, номер строки, само сообщение. 
4. Level (Уровень): 
• Каждое сообщение имеет уровень важности. Логгер фильтрует сообщения по этому уровню. 
• Стандартные уровни (от наименее к наиболее важному): 
        * DEBUG: Детальная информация, полезная при отладке. 
        * INFO: Подтверждение того, что все работает как ожидалось. 
* WARNING: Указание на то, что произошло что-то неожиданное, или проблема, которая будет решена в ближайшем будущем (например, "мало места на диске"). 
* ERROR: Из-за более серьезной проблемы программа не смогла выполнить какую-то функцию. 
* CRITICAL: Серьезная ошибка, указывающая на то, что сама программа, возможно, не сможет продолжать работу. 
• Логгер имеет свой собственный уровень (logger.setLevel()). Если уровень сообщения ниже уровня логгера, сообщение игнорируется. 

2. Aiomax
Библиотека aiomax предоставляет мощный и гибкий инструментарий для разработки ботов для Российского мессенджера MAX. Она построена на асинхронном фреймворке aiohttp, что обеспечивает высокую производительность и масштабируемость.
Центральным элементом библиотеки является класс Bot. Он выступает в роли главного роутера, обрабатывая входящие сообщения и команды.
Основные методы Bot:
•  Bot.get_me(): Получает информацию о текущем боте.
•  Bot.patch_me(...): Позволяет изменять информацию о боте (имя, описание, аватар).
•  Bot.get_chats(...): Получает список чатов, в которых состоит бот.
•  Bot.chat_by_link(link): Получает информацию о чате по его ссылке.
•  Bot.get_chat(chat_id): Получает информацию о чате по его ID.
•  Bot.get_pin(chat_id): Получает закрепленное сообщение в чате.
•  Bot.pin(...): Закрепляет сообщение в чате.
•  Bot.delete_pin(chat_id): Удаляет закрепленное сообщение.
•  Bot.my_membership(chat_id): Получает информацию о членстве бота в чате.
•  Bot.leave_chat(chat_id): Позволяет боту покинуть чат.
•  Bot.get_admins(chat_id): Получает список администраторов чата.
•  Bot.get_members(chat_id, count_per_iter): Возвращает асинхронный итератор пользователей в чате.
•  Bot.get_memberships(chat_id, user_ids): Получает информацию о пользователях по их ID.
•  Bot.add_members(chat_id, users): Добавляет пользователей в чат.
•  Bot.kick_member(chat_id, user_id): Удаляет пользователя из чата.
•  Bot.patch_chat(...): Изменяет информацию о чате (имя, иконка, закрепленное сообщение).
•  Bot.post_action(chat_id, action): Отправляет действие бота (например, "печатает").
•  Bot.upload(...): Загружает файлы на сервер (используйте специализированные методы для изображений, видео и аудио).
•  Bot.upload_image(...), Bot.upload_video(...), Bot.upload_audio(...): Загрузка медиафайлов.
•  Bot.send_message(...): Отправляет сообщения в чат или пользователю. Поддерживает форматирование, вложения, клавиатуры и ответы на сообщения.
•  Bot.edit_message(...): Редактирует содержимое отправленного сообщения.
•  Bot.delete_message(message_id): Удаляет сообщение.
•  Bot.start_polling(...): Запускает Long polling для получения обновлений.
•  Bot.run(): Удобный метод для запуска бота.
Кнопки и клавиатуры
Библиотека предоставляет гибкий механизм для создания интерактивных клавиатур с различными типами кнопок:
1.  buttons.KeyboardBuilder: Класс для построения клавиатур.
  	•  row(): Добавляет новый ряд кнопок.
  	•  add(): Добавляет кнопки к последнему ряду.
  	•  table(): Создает таблицу кнопок.
  	•  to_list(): Конвертирует клавиатуру в сериализуемый список.
2. Типы кнопок:
  	•  CallbackButton: Кнопка, при нажатии которой бот получает событие message_callback.
  	•  LinkButton: Кнопка-ссылка, открывающая веб-страницу.
  	•  GeolocationButton: Кнопка для отправки геолокации.
  	•  ContactButton: Кнопка для отправки контактной информации.
  	•  ChatButton: Кнопка для создания нового чата с участием бота.
Декораторы
Декораторы используются для обработки различных событий, поступающих от MAX API:
•  @bot.on_message(...): Обработка входящих сообщений. Поддерживает фильтры.
•  @bot.on_message_edit(...): Обработка редактирования сообщений.
•  @bot.on_message_delete(...): Обработка удаления сообщений.
•  @bot.on_bot_start(): Вызывается при нажатии кнопки "Начать".
•  @bot.on_ready(): Вызывается перед началом поллинга.
•  @bot.on_command(...): Обработка команд с префиксами.
•  @bot.on_button_callback(...): Обработка нажатий на CallbackButton.
•  @bot.on_button_chat_create(): Обработка нажатий на ChatButton.
•  @bot.on_bot_add(): Отслеживание добавления бота в чаты.
•  @bot.on_bot_remove(): Отслеживание удаления бота из чатов.
•  @bot.on_user_add(): Отслеживание добавления пользователей в чаты.
•  @bot.on_user_remove(): Отслеживание удаления пользователей из чатов.
•  @bot.on_chat_title_change(): Отслеживание изменений названий чатов.
Фильтры	
Фильтры позволяют более тонко настраивать обработку событий. aiomax предоставляет встроенные фильтры, а также возможность создавать собственные:
1. Встроенные фильтры:
  	•  aiomax.filters.equals(content): Проверяет точное совпадение контента.
 	•  aiomax.filters.has(content): Проверяет наличие подстроки в контенте.
  	•  aiomax.filters.startswith(prefix): Проверяет начало контента.
  	•  aiomax.filters.endswith(suffix): Проверяет конец контента.
  	•  aiomax.filters.regex(pattern): Проверяет соответствие регулярному выражению.
  	•  aiomax.filters.papaya: Специальный фильтр для проверки предпоследнего слова.
  	•  aiomax.filters.state(state): Проверяет состояние пользователя (для FSM).
2.  Собственные фильтры: Можно создавать с помощью lambda-выражений, функций или классов.
